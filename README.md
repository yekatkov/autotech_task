# Что имеем
Исходный файл для данного задания представляет типичный вариант "макаронной архитектуры", когда все имеют доступ ко 
всему и лезут не в свои зоны ответсвенности, вот некоторые моменты, которые бросаются в глаза:
* receiver по-сути меняет код, который передаёт ему transmitter.
* recever не ждёт события, что пакет пришёл, и просто нон-стоп читает структуру, что приводит к отличному результату
от запуска к запуску.
* в main очень много синхронизирующего кода, который должен находится в отдельных классах.

# Что предлагается сделать
Как будто функции send_can_frame и receive_udp относятся к разным уровням модели передачи данных, первая передаёт фреймы с блоком данных заданного размера, а вторая читает из входного буфера блоки произвольного размера, заданного в buffer_size, т.е. передаём мы скорее на прикладном уровне, а читаем на уровне драйверов.

Чтобы сделать систему масштабируемой с возможнотью менять прикладную часть, а так же способ передачи данных, реализуем трёхуровневую модель:
* Прикладной уровень: на нём реализуем зачатки протокола и будем формировать данные для передачи (UdpData), а так же команды.
* Транспортный уровень: на нём из входных данных мы будем формировать CanFrame (по-хорошему нужно реализовать здесь формирование заголовка и проверку целостности данных, но, подозреваю, что это выходит за рамки ТЗ)
* Канальный/физический уровень: на этом уровне мы реализуем эмуляцию передачи данных на уровне "железа"

Чтобы обеспечить изоляцию между приёмником и передатчиком, мы немного усложним CanFrame, добавив в него кадры данных и кадры команд, чтобы иметь возможность инициировать остановку потока приёмника через команду STOP.

main() функция превратилась в своего рода smoke-test: мы по прежнему передаём 100 пакетов, но только половина должна отфильтроваться по deviceID (аналог canFrameId). Так же в конце main() мы проверим, что мы получили ровно то же, что и передали. Задержку же при передаче уберём вовсе, чтобы добавить конкурентности в обработке данных.

# Как будем делать
Разделим наши 3 уровня на 3 модуля, каждый из которых будет помещён в отдельную директорию Application, TransportLayer, PhysicalLayerEmulator, а так же добавим модуль Utils, в который мы помести простенький потокобезопасный логгер, так как в main() функции мы пишем в stdout в параллельных потоках. В каждой директории будет public и private часть, в первой будут объявлены интерфейсные классы и определены классы фабрик, а во второй - вся логика работы, которую мы скроем от пользователя.

Можно, конечно, каждый модуль скомпилировать в виде отдельной либы, но и это, полагаю, не требуется в рамках данного ТЗ.

Диаграмма классов, описывающая реализацию: https://drive.google.com/file/d/1rZZEUEY-3WENzNsEc8MelYYtIfRIo-TL/view?usp=sharing

## Application layer
Уровень приложения разделён на два класса: приёмник и передатчик, каждый из которых отнаследован от общего класса XYTransceiver, реализующего базовый метод получения deviceId - адрес, по которому происходит адресация пакетов (внутри мапится в canFrameId)

## Transport layer
На этом уровне мы предоставляем интерфейс взаимодействия, чтобы иметь возможность в случае необходимости поменять CAN интерфейс на что-то ещё без необходимости переписывать много кода. Объект CanInterface-а получаем при помощи фабрики, указывая адрес устройства.

Чтобы не формировать из заголовка и полезной нагрузки отдельный пакет, копируя в него данные, была использована блокировка канала для записи и чтения целиком, чтобы не было перемешивания блоков пакетов из разных потоков. На конкурентное чтение во время записи данное решение не скажется, так как при чтении нам важно, чтобы пакет не распадался, а то, что какие-то блоки записываются по-ходу чтения роли не играет.

## Physical layer
Самый низкий уровень абстракции по-сути является эмулятором. Хотелось навернуть там побольше функционала, но пришлось себя сдерживать, помятуя, что цели данного ТЗ явно не в этом.

В итоге канал реализован при помощи очереди, а так же условной переменной с прилагающимся к ней мьютексом, которые обеспечат возможность конкурентных записи и чтения.

Так же добавил пару методов, которые защищают канал целиком во время записи или чтения, о которых писалось выше.
